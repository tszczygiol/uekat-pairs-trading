# -*- coding: utf-8 -*-
"""pairs_trading_notebook

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/15UDJuWRHqs1RT5Gm8oYkHREcjLTq5tZy

## Importing all the necessary libraries

* pandas, numpy; for mathematical functions and dataframes
* seaborn and matplotlib; plotting the data
* datetime; for dates
* pandas_datareader; access to the OHLCV data
* statsmodels; for cointegration, statistical tests
"""

import pandas as pd
import numpy as np
import yfinance as yf

import seaborn as sns
import matplotlib.pyplot as plt


import datetime as dt
from pandas_datareader import data as pdr

import statsmodels.tsa.stattools as ts
import statsmodels.api as sm

"""## Defining the inputs

"""

start = dt.datetime(2013, 1, 1)
end = dt.datetime(2019, 1, 1)


ticker_polskie = ['STX','BDX','ALE','DNP']

"""## Downloading OHLCV data using pandas datareader"""

df = pdr.DataReader(ticker_polskie, 'stooq', start, end)

df

df_close = df['Close']

"""## Correlation matrix between closing prices of stocks"""

plt.figure(figsize=(16, 6))

sns.heatmap(df_close.corr(), vmin=-1, vmax=1, annot=True)

"""## Separating close prices of BDX and ALE to variables, and plotting the line chart of prices"""

bdx_close = df_close['BDX']
ale_close = df_close['ALE']
print(ale_close)

plt.figure(figsize=(16,6))


plt.xlabel('Date')
plt.ylabel('Price')
plt.title('Closing Prices')
plt.plot(bdx_close, label='BDX')
plt.plot(ale_close, label='ALE', color="green")
plt.legend()
plt.show()

"""## Calculating hedge ratio, and spread

Y variable is BDX
X variable is ALE

"""

Y = bdx_close
X = ale_close

X = sm.add_constant(X)

model = sm.OLS(Y, X).fit()
beta = model.params[1]

print(f'Hedge Ratio (Beta): {beta}')
spread = bdx_close - beta * ale_close
spread

"""## Augmented Dickey-Fulley test for stationarity of time series (spread)

H0: Spread is not stationary

H1: Spread is stationary

Requirement for this strategy is the spread needs to be stationary.
"""

adf_test = ts.adfuller(spread)

print(f'ADF Statistic: {adf_test[0]}, p-value: {adf_test[1]}')

if adf_test[1] < 0.05:
    print("Null hypothesis is rejected - Spread is stationary")
else:
    print("Fail to reject Null hypothesis - Spread is not stationary")

"""## Standardizing the spread

"""

z_scores = (spread -spread.mean())/spread.std()

"""## Creating bounds for signals, and visualizing the z_scores time series."""

band = 1.5
plt.figure(figsize=(16,9))
# --- Z-scores
plt.plot(z_scores, label="Z-scores")

# --- Bands
plt.axhline(band, color="red", label="+1,5σ")
plt.axhline(-1 *band, color="red", label="-1,5σ")

plt.title("Z-scores  +-1,5σ")
plt.xlabel("Date")
plt.ylabel("Z-scores")
plt.legend(loc='upper left')
plt.show()

"""## Long and short signals"""

long_signal = (z_scores.shift(1) >= -1.5) & (z_scores < -1.5)
short_signal = (z_scores.shift(1) <= 1.5) & (z_scores > 1.5)

plt.figure(figsize=(16,9))

plt.plot(z_scores, label="z-scores")
plt.axhline(band, color="red", label="+1,5σ")
plt.axhline(-1 *band, color="red", label="-1,5σ")

plt.scatter(z_scores.index[long_signal], z_scores[long_signal], color='green', marker='^', label='Long', alpha=1)
plt.scatter(z_scores.index[short_signal], z_scores[short_signal], color='red', marker='v', label='Short', alpha=1)

plt.title("Z-scores with bands, and long/short signals")
plt.xlabel("Date")
plt.ylabel("Z-scores")
plt.legend()
plt.show()

"""# BACKTEST SECTION

## Creating dataframe with prices and signals
"""

trade_df = pd.concat([bdx_close,ale_close,long_signal,short_signal], axis=1)
trade_df.columns = ['Close Long', 'Close Short', 'Long Signal', 'Short Signal']
trade_df

"""## Backtest and summary of trade"""

initial_cash = 0
cash = initial_cash
positions = []

returns = []

position_open = False
position_type = None
entry_bdx = 0
entry_ale = 0

for i in range(1, len(trade_df)):
    if long_signal.iloc[i]:
        position_open = True
        position_type = 'long'
        entry_bdx = bdx_close.iloc[i]
        entry_ale = ale_close.iloc[i]
    elif short_signal.iloc[i]:
        position_open = True
        position_type = 'short'
        entry_bdx = bdx_close.iloc[i]
        entry_ale = ale_close.iloc[i]

    if position_open:
        current_bdx = bdx_close.iloc[i]
        current_ale = ale_close.iloc[i]

        if position_type == 'long':
            pnl = (current_bdx - entry_bdx) - beta * (current_ale - entry_ale)
        elif position_type == 'short':
            pnl = (entry_bdx - current_bdx) - beta * (entry_ale - current_ale)
        else:
            pnl = 0

        returns.append(pnl)

        if abs(z_scores.iloc[i]) < 0.5:
            cash += pnl
            position_open = False
            position_type = None

total_pnl = sum(returns)
num_trades = len(returns)
average_pnl = total_pnl / num_trades if num_trades > 0 else 0
max_drawdown = min(returns) if returns else 0
sharpe_ratio = np.mean(returns) / np.std(returns) * np.sqrt(252) if np.std(returns) > 0 else 0


summary_df = pd.DataFrame({
    'Miary': [
        'Łączny zysk/strata',
        'Liczba transakcji',
        'Średni zysk na transakcję',
        'Max Drawdown',
        'Sharpe Ratio'
    ],
    'Wartości': [
        round(total_pnl, 2),
        num_trades,
        round(average_pnl, 2),
        round(max_drawdown, 2),
        round(sharpe_ratio, 2)
    ]
})

from tabulate import tabulate
print(tabulate(summary_df, headers='keys', tablefmt='fancy_grid', showindex=False))